import type {
  ITask,
  Profile,
  TaskData,
  TaskResponse,
  AddressBook,
  EntryPointListResponse,
  AddressBookEntriesResponse,
  ContactServiceQueuesResponse,
} from '@webex/contact-center';
import {IContactCenter} from '@webex/cc-store';

const mockProfile: Profile = {
  teams: [{teamId: 'team1', teamName: 'Team 1'}],
  defaultDn: '12345',
  dn: '12345',
  forceDefaultDn: false,
  forceDefaultDnForAgent: false,
  regexUS: '',
  regexOther: '',
  agentId: 'agent1',
  agentName: 'John Doe',
  agentMailId: 'agent@example.com',
  agentProfileID: 'profile123',
  dialPlan: {
    type: 'adhocDial',
    dialPlanEntity: [],
  },
  multimediaProfileId: 'mm123',
  skillProfileId: 'skill123',
  siteId: 'site123',
  enterpriseId: 'enterprise123',
  privacyShieldVisible: false,
  idleCodes: [{id: 'code1', name: 'Code 1', isSystem: false, isDefault: false}],
  idleCodesList: [],
  idleCodesAccess: 'ALL',
  wrapupCodes: [{id: 'wrap1', name: 'Wrap Code 1', isSystem: false, isDefault: false}],
  defaultWrapupCode: 'wrap1',
  wrapUpData: {
    wrapUpProps: {
      autoWrapup: false,
      autoWrapupInterval: 0,
      lastAgentRoute: false,
      wrapUpReasonList: [],
      wrapUpCodesList: [],
      idleCodesAccess: 'ALL',
      allowCancelAutoWrapup: false,
    },
  },
  orgId: 'org1',
  isOutboundEnabledForTenant: false,
  isOutboundEnabledForAgent: false,
  isAdhocDialingEnabled: true,
  isAgentAvailableAfterOutdial: false,
  isCampaignManagementEnabled: true,
  outDialEp: '',
  isEndCallEnabled: true,
  isEndConsultEnabled: true,
  agentDbId: 'agentDb123',
  allowConsultToQueue: true,
  agentPersonalStatsEnabled: true,
  isTimeoutDesktopInactivityEnabled: false,
  timeoutDesktopInactivityMins: 30,
  loginVoiceOptions: ['BROWSER'],
  deviceType: 'BROWSER',
  currentTeamId: 'team1',
  webRtcEnabled: true,
  lostConnectionRecoveryTimeout: 30000,
  maskSensitiveData: false,
  isAgentLoggedIn: true,
  lastStateAuxCodeId: 'auxCodeId',
  lastStateChangeTimestamp: 123456789,
  lastIdleCodeChangeTimestamp: 123456789,
};

const mockEntryPointsResponse: EntryPointListResponse = {
  data: [
    {
      id: 'ep1',
      name: 'Entry 1',
      type: 'Voice',
      isActive: true,
      orgId: 'org1',
    },
  ],
  meta: {page: 0, pageSize: 25, totalPages: 1},
};

const mockAddressBookEntriesResponse: AddressBookEntriesResponse = {
  data: [
    {
      id: 'ab1',
      name: 'Alice',
      number: '123',
      organizationId: 'org1',
      version: 1,
      createdTime: 1704067200000,
      lastUpdatedTime: 1704067200000,
    },
  ],
  meta: {page: 0, pageSize: 25, totalPages: 1},
};

const makeMockAddressBook = (getEntriesMock?: AddressBook['getEntries']): AddressBook =>
  ({
    getEntries: getEntriesMock || jest.fn().mockResolvedValue(mockAddressBookEntriesResponse),
    // Need to add this only for AddressBook type
    // eslint-disable-next-line @typescript-eslint/no-empty-object-type
  }) as {} as AddressBook;

const mockAddressBook = makeMockAddressBook();

const mockTask: ITask = {
  data: {
    interaction: {
      mediaType: 'telephony',
      participants: {
        agent1: {
          hasJoined: true,
        },
      },
    },
    agentId: 'agent1',
  } as TaskData,
  webCallMap: {},
  autoWrapup: undefined,
  on: jest.fn(),
  off: jest.fn(),
  emit: jest.fn(),
  addListener: jest.fn(),
  once: jest.fn(),
  removeListener: jest.fn(),
  removeAllListeners: jest.fn(),
  setMaxListeners: jest.fn(),
  getMaxListeners: jest.fn().mockReturnValue(10),
  listeners: jest.fn().mockReturnValue([]),
  rawListeners: jest.fn().mockReturnValue([]),
  listenerCount: jest.fn().mockReturnValue(0),
  prependListener: jest.fn(),
  prependOnceListener: jest.fn(),
  eventNames: jest.fn().mockReturnValue([]),
  cancelAutoWrapupTimer: jest.fn(),
  unregisterWebCallListeners: jest.fn(),
  updateTaskData: jest.fn().mockReturnValue({} as ITask),
  accept: jest.fn().mockResolvedValue({} as TaskResponse),
  decline: jest.fn().mockResolvedValue({} as TaskResponse),
  hold: jest.fn().mockResolvedValue({} as TaskResponse),
  resume: jest.fn().mockResolvedValue({} as TaskResponse),
  end: jest.fn().mockResolvedValue({} as TaskResponse),
  wrapup: jest.fn().mockResolvedValue({} as TaskResponse),
  pauseRecording: jest.fn().mockResolvedValue({} as TaskResponse),
  resumeRecording: jest.fn().mockResolvedValue({} as TaskResponse),
  //@ts-expect-error  To be fixed in SDK - https://jira-eng-sjc12.cisco.com/jira/browse/CAI-6762
  consult: jest.fn().mockResolvedValue({} as TaskResponse),
  transfer: jest.fn().mockResolvedValue({} as TaskResponse),
  consultTransfer: jest.fn().mockResolvedValue({} as TaskResponse),
  endConsult: jest.fn().mockResolvedValue({} as TaskResponse),
};

const mockQueueDetails = [
  {
    id: 'q1',
    name: 'Queue1',
    description: 'Test Queue 1',
    queueType: 'INBOUND' as const,
    checkAgentAvailability: true,
    channelType: 'TELEPHONY' as const,
    skillProfileId: 'skill1',
    siteId: 'site1',
    version: 1,
    isActive: true,
    maxWaitTime: 300,
    serviceLevelThreshold: 20,
    serviceLevelType: 'percentage',
    maxHandlingTime: 600,
    abandonedThreshold: 30,
    distributionPolicy: 'longest_idle',
    routingPolicy: 'skill_based',
    wrapUpTime: 60,
    autoAnswer: false,
    recordingPolicy: 'always',
    monitoringPolicy: 'supervisor',
    scriptId: 'script1',
    surveyId: 'survey1',
    outdialANI: '1234567890',
    outdialMethod: 'progressive',
    dialMode: 'preview',
    maxAttempts: 3,
    dialingOrder: 'priority',
    timeZoneHandling: 'agent',
    callbackOption: true,
    priority: 1,
    teamId: 'team1',
    maxActiveContacts: 10,
    maxTimeInQueue: 600,
    defaultMusicInQueueMediaFileId: 'music1',
    timezone: 'UTC',
    allowedWaitTimeMusicFiles: ['music1'],
    musicInQueueFileType: 'mp3',
    outdialRetryInterval: 300,
    maxQueueSize: 100,
    enableCallback: true,
    enableBusyRedial: false,
    busyRedialDelay: 60,
    skillMatchingEnabled: true,
    roundRobinRotation: true,
    preserveAgentOnTransfer: false,
    enableAgentToAgentTransfer: true,
    enableQueueToQueueTransfer: true,
    enableConferencing: true,
    maxConferenceParticipants: 6,
    enableWhisper: false,
    enableBarge: false,
    emergencyContactNumber: '911',
    active: true,
    outdialCampaignEnabled: false,
    monitoringPermitted: true,
    parkingPermitted: true,
    conferencePermitted: true,
    consultPermitted: true,
    transferPermitted: true,
    holdPermitted: true,
    breakoutPermitted: false,
    superQueueEnabled: false,
    workflowId: 'workflow1',
    businessRuleId: 'rule1',
    outboundAni: '1234567890',
    ringingTimeoutInterval: 20,
    bargePermitted: true,
    whisperPermitted: true,
    organizationId: 'org1',
    enterpriseId: 'enterprise1',
    recordingPermitted: true,
    recordingAllCallsPermitted: true,
    pauseRecordingPermitted: true,
    recordingPauseDuration: 30,
    callRecordingEnabled: true,
    screenRecordingEnabled: false,
    mediaStreamingEnabled: false,
    transcriptionEnabled: false,
    realTimeTranscriptionEnabled: false,
    queueStatisticsEnabled: true,
    controlFlowScriptUrl: 'https://example.com/script1.js',
    ivrRequeueUrl: 'https://example.com/requeue1',
    routingType: 'SKILLS_BASED' as const,
    queueRoutingType: 'SKILL_BASED' as const,
    callParkingUrl: 'https://example.com/parking1',
    overflowQueueId: 'overflow1',
    queueContactLimit: 100,
    queueAgentLimit: 50,
    enableVoicemail: true,
    voicemailGreeting: 'Hello, please leave a message',
    queueSkillRequirements: [{id: 'skill1', name: 'Skill 1'}],
    agents: [
      {id: 'agent1', name: 'Agent 1'},
      {id: 'agent2', name: 'Agent 2'},
    ],
    callDistributionGroups: [{id: 'group1', name: 'Group 1', agentGroups: [], order: 1, duration: 30}],
    links: [
      'https://api.example.com/queues/q1',
      'https://api.example.com/queues/q1/agents',
      'https://api.example.com/queues/q1/stats',
    ],
    createdBy: 'admin',
    lastModified: '2024-01-01T00:00:00Z',
    createdTime: '2024-01-01T00:00:00Z',
    lastUpdatedTime: '2024-01-01T00:00:00Z',
  },
  {
    id: 'q2',
    name: 'Queue2',
    description: 'Test Queue 2',
    queueType: 'INBOUND' as const,
    checkAgentAvailability: true,
    channelType: 'TELEPHONY' as const,
    skillProfileId: 'skill2',
    siteId: 'site1',
    version: 1,
    isActive: true,
    maxWaitTime: 300,
    serviceLevelThreshold: 20,
    serviceLevelType: 'percentage',
    maxHandlingTime: 600,
    abandonedThreshold: 30,
    distributionPolicy: 'longest_idle',
    routingPolicy: 'skill_based',
    wrapUpTime: 60,
    autoAnswer: false,
    recordingPolicy: 'always',
    monitoringPolicy: 'supervisor',
    scriptId: 'script2',
    surveyId: 'survey2',
    outdialANI: '1234567890',
    outdialMethod: 'progressive',
    dialMode: 'preview',
    maxAttempts: 3,
    dialingOrder: 'priority',
    timeZoneHandling: 'agent',
    callbackOption: true,
    priority: 2,
    teamId: 'team1',
    maxActiveContacts: 10,
    maxTimeInQueue: 600,
    defaultMusicInQueueMediaFileId: 'music2',
    timezone: 'UTC',
    allowedWaitTimeMusicFiles: ['music2'],
    musicInQueueFileType: 'mp3',
    outdialRetryInterval: 300,
    maxQueueSize: 100,
    enableCallback: true,
    enableBusyRedial: false,
    busyRedialDelay: 60,
    skillMatchingEnabled: true,
    roundRobinRotation: true,
    preserveAgentOnTransfer: false,
    enableAgentToAgentTransfer: true,
    enableQueueToQueueTransfer: true,
    enableConferencing: true,
    maxConferenceParticipants: 6,
    enableWhisper: false,
    enableBarge: false,
    emergencyContactNumber: '911',
    active: true,
    outdialCampaignEnabled: false,
    monitoringPermitted: true,
    parkingPermitted: true,
    conferencePermitted: true,
    consultPermitted: true,
    transferPermitted: true,
    holdPermitted: true,
    breakoutPermitted: false,
    superQueueEnabled: false,
    workflowId: 'workflow2',
    businessRuleId: 'rule2',
    outboundAni: '1234567890',
    ringingTimeoutInterval: 20,
    bargePermitted: true,
    whisperPermitted: true,
    organizationId: 'org1',
    enterpriseId: 'enterprise1',
    recordingPermitted: true,
    recordingAllCallsPermitted: true,
    pauseRecordingPermitted: true,
    recordingPauseDuration: 30,
    callRecordingEnabled: true,
    screenRecordingEnabled: false,
    mediaStreamingEnabled: false,
    transcriptionEnabled: false,
    realTimeTranscriptionEnabled: false,
    queueStatisticsEnabled: true,
    controlFlowScriptUrl: 'https://example.com/script2.js',
    ivrRequeueUrl: 'https://example.com/requeue2',
    routingType: 'SKILLS_BASED' as const,
    queueRoutingType: 'SKILL_BASED' as const,
    callParkingUrl: 'https://example.com/parking2',
    overflowQueueId: 'overflow2',
    queueContactLimit: 100,
    queueAgentLimit: 50,
    enableVoicemail: true,
    voicemailGreeting: 'Hello, please leave a message',
    queueSkillRequirements: [{id: 'skill2', name: 'Skill 2'}],
    agents: [
      {id: 'agent3', name: 'Agent 3'},
      {id: 'agent4', name: 'Agent 4'},
    ],
    callDistributionGroups: [{id: 'group2', name: 'Group 2', agentGroups: [], order: 1, duration: 30}],
    links: [
      'https://api.example.com/queues/q2',
      'https://api.example.com/queues/q2/agents',
      'https://api.example.com/queues/q2/stats',
    ],
    createdBy: 'admin',
    lastModified: '2024-01-01T00:00:00Z',
    createdTime: '2024-01-01T00:00:00Z',
    lastUpdatedTime: '2024-01-01T00:00:00Z',
  },
];

const mockAgents = [
  {
    id: 'a1',
    name: 'Agent1',
    agentId: 'a1',
    agentName: 'Agent1',
    state: 'Available',
    teamId: 'team1',
    dn: '1001',
    email: 'agent1@example.com',
    extension: '1001',
    siteId: 'site1',
  },
  {
    id: 'a2',
    name: 'Agent2',
    agentId: 'a2',
    agentName: 'Agent2',
    state: 'Available',
    teamId: 'team1',
    dn: '1002',
    email: 'agent2@example.com',
    extension: '1002',
    siteId: 'site1',
  },
];

const mockQueuesResponse: ContactServiceQueuesResponse = {
  data: mockQueueDetails.map((q) => ({
    id: q.id,
    version: q.version,
    name: q.name,
    description: q.description,
    queueType: q.queueType,
    checkAgentAvailability: q.checkAgentAvailability,
    channelType: q.channelType,
    serviceLevelThreshold: q.serviceLevelThreshold,
    maxActiveContacts: q.maxActiveContacts,
    maxTimeInQueue: q.maxTimeInQueue,
    defaultMusicInQueueMediaFileId: q.defaultMusicInQueueMediaFileId,
    timezone: q.timezone,
    active: q.active,
    outdialCampaignEnabled: q.outdialCampaignEnabled,
    monitoringPermitted: q.monitoringPermitted,
    parkingPermitted: q.parkingPermitted,
    recordingPermitted: q.recordingPermitted,
    recordingAllCallsPermitted: q.recordingAllCallsPermitted,
    pauseRecordingPermitted: q.pauseRecordingPermitted,
    recordingPauseDuration: q.recordingPauseDuration,
    controlFlowScriptUrl: q.controlFlowScriptUrl,
    ivrRequeueUrl: q.ivrRequeueUrl,
    overflowNumber: q.overflowQueueId,
    routingType: q.routingType,
    queueRoutingType: q.queueRoutingType,
    queueSkillRequirements: q.queueSkillRequirements?.map((s) => ({
      skillId: s.id,
      skillName: s.name,
      condition: 'EQUALS',
      skillValue: '1',
    })),
    agents: q.agents?.map((a) => ({id: a.id})),
    callDistributionGroups: q.callDistributionGroups,
    createdTime: typeof q.createdTime === 'number' ? q.createdTime : Date.parse(String(q.createdTime)),
    lastUpdatedTime: typeof q.lastUpdatedTime === 'number' ? q.lastUpdatedTime : Date.parse(String(q.lastUpdatedTime)),
  })),
  meta: {page: 0, pageSize: 25, totalPages: 1},
};

const mockCC: IContactCenter = {
  on: jest.fn(),
  off: jest.fn(),
  updateAgentProfile: jest.fn(),
  stationLogin: jest.fn(),
  deregister: jest.fn(),
  stationLogout: jest.fn(),
  LoggerProxy: {
    log: jest.fn(),
    error: jest.fn(),
    warn: jest.fn(),
    info: jest.fn(),
    trace: jest.fn(),
  },
  register: jest.fn(),
  taskManager: {
    getAllTasks: jest.fn().mockReturnValue({}),
  },
  getBuddyAgents: jest.fn().mockResolvedValue(mockAgents),
  getQueues: jest.fn().mockResolvedValue(mockQueuesResponse),
  getEntryPoints: jest.fn().mockResolvedValue(mockEntryPointsResponse),
  addressBook: mockAddressBook,
  setAgentState: jest.fn().mockResolvedValue({}),
};

export {
  mockProfile,
  mockCC,
  mockTask,
  mockQueueDetails,
  mockAgents,
  mockEntryPointsResponse,
  mockAddressBookEntriesResponse,
  makeMockAddressBook,
};
